{"ast":null,"code":"import stringSimilarity from \"string-similarity\";\nimport { FixedStats } from \"../Datas/Stats\";\nimport { correctionMap } from \"../func/TextCorrection\";\nexport function OcrRetouch({\n  text,\n  lang\n}) {\n  if (!text || !Array.isArray(text)) return {\n    retType: [],\n    retValue: []\n  };\n  if (!lang) lang = \"en\";\n  const statList = FixedStats.map(stat => stat[lang]).filter(Boolean);\n  const correction = correctionMap[lang] || {};\n  const correctedText = text.map(t => correction[t.trim()] || t.trim());\n  let startIndex = -1;\n  for (let i = 0; i < correctedText.length; i++) {\n    const {\n      bestMatch\n    } = stringSimilarity.findBestMatch(correctedText[i], statList);\n    if (bestMatch.rating > 0.7) {\n      startIndex = i;\n      break;\n    }\n  }\n  if (startIndex === -1 || startIndex + 13 >= correctedText.length) {\n    return {\n      retType: [],\n      retValue: []\n    };\n  }\n  const rawTypes = [];\n  const rawValues = [];\n  for (let i = 0; i < 14; i += 2) {\n    const key = correctedText[startIndex + i];\n    const val = correctedText[startIndex + i + 1];\n    const {\n      bestMatch\n    } = stringSimilarity.findBestMatch(key, statList);\n    const matched = bestMatch.rating > 0.7 ? bestMatch.target : null;\n    if (matched) {\n      rawTypes.push(matched);\n      rawValues.push(val);\n    }\n  }\n  const retType = [];\n  const retValue = [];\n  for (let i = 0; i < rawTypes.length; i++) {\n    var _candidates$;\n    const label = rawTypes[i];\n    const value = parseFloat(rawValues[i]);\n    const candidates = FixedStats.filter(stat => stat[lang] === label);\n    let selectedId = ((_candidates$ = candidates[0]) === null || _candidates$ === void 0 ? void 0 : _candidates$.id) || null;\n    if (candidates.length > 1) {\n      const hasPct = candidates.find(c => c.id.includes(\"Pct\"));\n      const hasRaw = candidates.find(c => !c.id.includes(\"Pct\"));\n      if (hasPct && hasRaw) {\n        selectedId = value > 30 ? hasRaw.id : hasPct.id;\n      }\n    }\n    retType.push(selectedId);\n    retValue.push(value.toFixed(1));\n  }\n  return {\n    retType,\n    retValue\n  };\n}\n_c = OcrRetouch;\nvar _c;\n$RefreshReg$(_c, \"OcrRetouch\");","map":{"version":3,"names":["stringSimilarity","FixedStats","correctionMap","OcrRetouch","text","lang","Array","isArray","retType","retValue","statList","map","stat","filter","Boolean","correction","correctedText","t","trim","startIndex","i","length","bestMatch","findBestMatch","rating","rawTypes","rawValues","key","val","matched","target","push","_candidates$","label","value","parseFloat","candidates","selectedId","id","hasPct","find","c","includes","hasRaw","toFixed","_c","$RefreshReg$"],"sources":["d:/project/_CodeFiles/wuthering/frontend/src/func/OcrRetouch.js"],"sourcesContent":["import stringSimilarity from \"string-similarity\";\r\nimport { FixedStats } from \"../Datas/Stats\";\r\nimport { correctionMap } from \"../func/TextCorrection\";\r\n\r\nexport function OcrRetouch({ text, lang }) {\r\n  if (!text || !Array.isArray(text)) return { retType: [], retValue: [] };\r\n  if (!lang) lang = \"en\";\r\n\r\n  const statList = FixedStats.map(stat => stat[lang]).filter(Boolean);\r\n  const correction = correctionMap[lang] || {};\r\n  const correctedText = text.map((t) => correction[t.trim()] || t.trim());\r\n\r\n  let startIndex = -1;\r\n\r\n  for (let i = 0; i < correctedText.length; i++) {\r\n    const { bestMatch } = stringSimilarity.findBestMatch(correctedText[i], statList);\r\n    if (bestMatch.rating > 0.7) {\r\n      startIndex = i;\r\n      break;\r\n    }\r\n  }\r\n\r\n  if (startIndex === -1 || startIndex + 13 >= correctedText.length) {\r\n    return { retType: [], retValue: [] };\r\n  }\r\n\r\n  const rawTypes = [];\r\n  const rawValues = [];\r\n\r\n  for (let i = 0; i < 14; i += 2) {\r\n    const key = correctedText[startIndex + i];\r\n    const val = correctedText[startIndex + i + 1];\r\n\r\n    const { bestMatch } = stringSimilarity.findBestMatch(key, statList);\r\n    const matched = bestMatch.rating > 0.7 ? bestMatch.target : null;\r\n\r\n    if (matched) {\r\n      rawTypes.push(matched);\r\n      rawValues.push(val);\r\n    }\r\n  }\r\n\r\n  const retType = [];\r\n  const retValue = [];\r\n\r\n  for (let i = 0; i < rawTypes.length; i++) {\r\n    const label = rawTypes[i];\r\n    const value = parseFloat(rawValues[i]);\r\n\r\n    const candidates = FixedStats.filter(stat => stat[lang] === label);\r\n    let selectedId = candidates[0]?.id || null;\r\n\r\n    if (candidates.length > 1) {\r\n      const hasPct = candidates.find(c => c.id.includes(\"Pct\"));\r\n      const hasRaw = candidates.find(c => !c.id.includes(\"Pct\"));\r\n\r\n      if (hasPct && hasRaw) {\r\n        selectedId = value > 30 ? hasRaw.id : hasPct.id;\r\n      }\r\n    }\r\n\r\n    retType.push(selectedId);\r\n    retValue.push(value.toFixed(1));\r\n  }\r\n\r\n  return { retType, retValue };\r\n}\r\n"],"mappings":"AAAA,OAAOA,gBAAgB,MAAM,mBAAmB;AAChD,SAASC,UAAU,QAAQ,gBAAgB;AAC3C,SAASC,aAAa,QAAQ,wBAAwB;AAEtD,OAAO,SAASC,UAAUA,CAAC;EAAEC,IAAI;EAAEC;AAAK,CAAC,EAAE;EACzC,IAAI,CAACD,IAAI,IAAI,CAACE,KAAK,CAACC,OAAO,CAACH,IAAI,CAAC,EAAE,OAAO;IAAEI,OAAO,EAAE,EAAE;IAAEC,QAAQ,EAAE;EAAG,CAAC;EACvE,IAAI,CAACJ,IAAI,EAAEA,IAAI,GAAG,IAAI;EAEtB,MAAMK,QAAQ,GAAGT,UAAU,CAACU,GAAG,CAACC,IAAI,IAAIA,IAAI,CAACP,IAAI,CAAC,CAAC,CAACQ,MAAM,CAACC,OAAO,CAAC;EACnE,MAAMC,UAAU,GAAGb,aAAa,CAACG,IAAI,CAAC,IAAI,CAAC,CAAC;EAC5C,MAAMW,aAAa,GAAGZ,IAAI,CAACO,GAAG,CAAEM,CAAC,IAAKF,UAAU,CAACE,CAAC,CAACC,IAAI,CAAC,CAAC,CAAC,IAAID,CAAC,CAACC,IAAI,CAAC,CAAC,CAAC;EAEvE,IAAIC,UAAU,GAAG,CAAC,CAAC;EAEnB,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGJ,aAAa,CAACK,MAAM,EAAED,CAAC,EAAE,EAAE;IAC7C,MAAM;MAAEE;IAAU,CAAC,GAAGtB,gBAAgB,CAACuB,aAAa,CAACP,aAAa,CAACI,CAAC,CAAC,EAAEV,QAAQ,CAAC;IAChF,IAAIY,SAAS,CAACE,MAAM,GAAG,GAAG,EAAE;MAC1BL,UAAU,GAAGC,CAAC;MACd;IACF;EACF;EAEA,IAAID,UAAU,KAAK,CAAC,CAAC,IAAIA,UAAU,GAAG,EAAE,IAAIH,aAAa,CAACK,MAAM,EAAE;IAChE,OAAO;MAAEb,OAAO,EAAE,EAAE;MAAEC,QAAQ,EAAE;IAAG,CAAC;EACtC;EAEA,MAAMgB,QAAQ,GAAG,EAAE;EACnB,MAAMC,SAAS,GAAG,EAAE;EAEpB,KAAK,IAAIN,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,EAAE,EAAEA,CAAC,IAAI,CAAC,EAAE;IAC9B,MAAMO,GAAG,GAAGX,aAAa,CAACG,UAAU,GAAGC,CAAC,CAAC;IACzC,MAAMQ,GAAG,GAAGZ,aAAa,CAACG,UAAU,GAAGC,CAAC,GAAG,CAAC,CAAC;IAE7C,MAAM;MAAEE;IAAU,CAAC,GAAGtB,gBAAgB,CAACuB,aAAa,CAACI,GAAG,EAAEjB,QAAQ,CAAC;IACnE,MAAMmB,OAAO,GAAGP,SAAS,CAACE,MAAM,GAAG,GAAG,GAAGF,SAAS,CAACQ,MAAM,GAAG,IAAI;IAEhE,IAAID,OAAO,EAAE;MACXJ,QAAQ,CAACM,IAAI,CAACF,OAAO,CAAC;MACtBH,SAAS,CAACK,IAAI,CAACH,GAAG,CAAC;IACrB;EACF;EAEA,MAAMpB,OAAO,GAAG,EAAE;EAClB,MAAMC,QAAQ,GAAG,EAAE;EAEnB,KAAK,IAAIW,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGK,QAAQ,CAACJ,MAAM,EAAED,CAAC,EAAE,EAAE;IAAA,IAAAY,YAAA;IACxC,MAAMC,KAAK,GAAGR,QAAQ,CAACL,CAAC,CAAC;IACzB,MAAMc,KAAK,GAAGC,UAAU,CAACT,SAAS,CAACN,CAAC,CAAC,CAAC;IAEtC,MAAMgB,UAAU,GAAGnC,UAAU,CAACY,MAAM,CAACD,IAAI,IAAIA,IAAI,CAACP,IAAI,CAAC,KAAK4B,KAAK,CAAC;IAClE,IAAII,UAAU,GAAG,EAAAL,YAAA,GAAAI,UAAU,CAAC,CAAC,CAAC,cAAAJ,YAAA,uBAAbA,YAAA,CAAeM,EAAE,KAAI,IAAI;IAE1C,IAAIF,UAAU,CAACf,MAAM,GAAG,CAAC,EAAE;MACzB,MAAMkB,MAAM,GAAGH,UAAU,CAACI,IAAI,CAACC,CAAC,IAAIA,CAAC,CAACH,EAAE,CAACI,QAAQ,CAAC,KAAK,CAAC,CAAC;MACzD,MAAMC,MAAM,GAAGP,UAAU,CAACI,IAAI,CAACC,CAAC,IAAI,CAACA,CAAC,CAACH,EAAE,CAACI,QAAQ,CAAC,KAAK,CAAC,CAAC;MAE1D,IAAIH,MAAM,IAAII,MAAM,EAAE;QACpBN,UAAU,GAAGH,KAAK,GAAG,EAAE,GAAGS,MAAM,CAACL,EAAE,GAAGC,MAAM,CAACD,EAAE;MACjD;IACF;IAEA9B,OAAO,CAACuB,IAAI,CAACM,UAAU,CAAC;IACxB5B,QAAQ,CAACsB,IAAI,CAACG,KAAK,CAACU,OAAO,CAAC,CAAC,CAAC,CAAC;EACjC;EAEA,OAAO;IAAEpC,OAAO;IAAEC;EAAS,CAAC;AAC9B;AAACoC,EAAA,GA9De1C,UAAU;AAAA,IAAA0C,EAAA;AAAAC,YAAA,CAAAD,EAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}